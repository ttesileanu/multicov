function [res, Z] = getmaxentstatsslow(params_me, varargin)
% GETMAXENTSTATSSLOW Calculate positional frequencies and correlations from
% a maximum-entropy model by calculating all terms in the partition function.
%   res = GETMAXENTSTATSSLOW(params) returns the single-site frequencies and
%   correlations that would be obtained from an alignment generated by the
%   maximum entropy model with parameters given by 'params'. These are
%   calculated with a slow procedure that involves enumerating all the terms
%   in the partition function.
%
%   The maximum entropy parameters are extended as if they were in the gap
%   gauge if they do not include the gaps.
%
%   [res, Z] = GETMAXENTSTATSSLOW(...) also returns the partition function Z.
%
%   Note that this is only feasible for short sequences, as the run time
%   scales exponentially with the length. The code is currently single-threaded,
%   but it could be improved significantly by parallelization.
%
%   Options:
%    'dispinterval' <n>
%       Interval to output progress information, in seconds.
%       (default: 10)
%    'verbose'
%       Whether to output progress information.
%       (default: true)
%
% See also: INCLUDEGAPS.

% Tiberiu Tesileanu (2012-2014)

if nargin == 1 && ischar(params_me) && strcmp(params_me, 'hascpp')
    res = (exist('cppslowstats', 'file') == 3);
    return
end

parser = inputParser;
parser.CaseSensitive = true;
parser.FunctionName = mfilename;

parser.addParamValue('dispinterval', 10, @(x) isscalar(x) && isnumeric(x));
parser.addParamValue('nocpp', false, @(b) islogical(b) && isscalar(b));
parser.addParamValue('verbose', true, @(b) islogical(b) && isscalar(b));

% parse
parser.parse(varargin{:});
params = parser.Results;

params_me = paramsincludegaps(params_me);

% total number of states
structure = alphaexcludegaps(params_me);
ntotal = getnumberofstates(structure);
count = 0;
if params.verbose
    disp(['Total number of states: ' int2str(ntotal) '.']);
end

if ~params.nocpp && exist('cppslowstats', 'file') == 3
    alphabetletters = cellfun(@(a) alphagetletters(a), structure.alphabets, 'uniform', false);
    [fi, fij, Z] = cppslowstats(alphabetletters, structure.alphawidths, ...
        params_me.couplings, struct('dispinterval', params.dispinterval, ...
        'verbose', params.verbose));
else
    % track the state of the protein sequence, and iterate through all possible
    % states...
    % cache the alphabets for each position of the sequences
    lettersperpos = getlettersperpos(structure);
    nperpos = cellfun(@length, lettersperpos);
    n = length(nperpos);
    nstate = ones(1, n);
        
    % keep track of the partition function
    Z = 0;
    % keep track of frequencies and correlations
    alnmap = getbinmap(structure);
    L = alnmap{end}(end);
    
    fi = zeros(L, 1);
    fij = zeros(L);
    
    ticker = tic;
    displayed = false;
    while nstate(1) <= nperpos(1)
        state = arrayfun(@(i) lettersperpos{i}(nstate(i)), 1:n);
        energy = getmaxentenergies(state, params_me);
        
        t = toc(ticker);
        if params.verbose && t >= params.dispinterval
            disp(['Progress: ' num2str(100*count/ntotal, 4) '%.']);
            ticker = tic;
            displayed = true;
        end
        % update partition function and Pi, Pij
        exp_energy = exp(-energy);
        Z = Z + exp_energy;
        for i = 1:n
            ni = nstate(i);
            if ni < 2 % don't count gaps
                continue;
            end
            idxi = alnmap{i}(ni - 1);
            fi(idxi) = fi(idxi) + exp_energy;
            fij(idxi, idxi) = fij(idxi, idxi) + exp_energy;
            for j = (i+1):n
                nj = nstate(j);
                if nj < 2 % don't count gaps
                    continue;
                end
                idxj = alnmap{j}(nj - 1);
                fij(idxi, idxj) = fij(idxi, idxj) + exp_energy;
            end
        end
        
        % iterate
        nstate(n) = nstate(n) + 1;
        k = n;
        while k > 1 && nstate(k) > nperpos(k)
            nstate(k) = 1;
            k = k - 1;
            nstate(k) = nstate(k) + 1;
        end
        count = count + 1;
    end
    
    fij = fij + tril(fij', -1);
    
    if params.verbose && displayed
        disp('Done.');
    end
    
    % normalize the probabilities
    fi = fi/Z;
    fij = fij/Z;
end

% create the output structure
res.type = 'stats';
res.freq1 = fi;
res.freq2 = fij;
res.cmat = fij - kron(fi, fi');
res.alphabets = structure.alphabets;
res.alphawidths = structure.alphawidths;
res.refseq = structure.refseq;

end

function n = getnumberofstates(params)
% GETNUMBEROFSTATES Calculate the number of possible sequences given the
% structure.
%   n = GETNUMBEROFSTATES(structure) calculates the total number of
%   possible sequences with the given structure.

n = prod(cellfun(@(a) length(alphagetletters(a)), params.alphabets(:)).^params.alphawidths(:));

end

function list = getlettersperpos(params)
% GETLETTERSPERPOS For each position in the sequence, cache the string of
% allowed letters.
%   list = GETLETTERSPERPOS(params) returns a cell array of size
%   sum(structure.alphawidths), in which each cell is a string of allowed
%   letters at the corresponding position.

list = {};
for i = 1:length(params.alphabets)
    letters = alphagetletters(params.alphabets{i});
    list = [list repmat({letters}, 1, params.alphawidths(i))]; %#ok<AGROW>
end

end